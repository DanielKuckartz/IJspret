Stelling
	De worst-case heeft in elke rij en kolom een zo gelijk mogelijk aantal verboden velden.

"Bewijs"
	Dan heeft voor een willekeurig geplaatste dame het bord D in 'Torenveelterm::eigenschap2'
		zo veel mogelijk resterende verboden velden. Het aantal keer dat bord E in deze functie gemaakt wordt is gelijk aan het aantal keer
		dat bord D gemaakt wordt. Hierna moeten we verder rekenen met beide borden. We willen dus zo min mogelijk aantal keer eigenschap2 uitvoeren.
	Dat is equivalent met zeggen dat we zo min mogelijk aantal borden D willen maken. Dus we willen, met eigenschap2 in het achterhoofd, elke rij en kolom zo gelijk mogelijk
		aantal verboden velden geven.
	We willen ook weten hoe vaak eigenschap1 aangeroepen wordt. Als er geen bord D gemaakt zou worden, dan is het aantal aanroepen gelijk aan het minimum tussen het aantal
		niet-lege kolommen en het aantal niet-lege rijen. Voor elke keer dat het bord D gemaakt wordt, beschouw een nieuwe Torenveelterm instantie met het bord D. Hiervan weten we, als we geen borden D zouden maken, het aantal aanroepen van eigenschap 1. Het (recursief bepaalde) resultaat moeten we optellen het aantal aanroepen van eigenschap 1 in de vorige Torenveelterm instantie. Oftewel: het aantal aanroepen van eigenschap1 sterk afhangt van het aantal borden D dat gemaakt wordt. We concluderen dat de stelling juist is.


Stelling
	De functie 'Torenveelterm::maakequivalent' maakt inderdaad een bord aan waarvoor de veelterm gelijk is aan die van het oorspronkelijke bord.

"Bewijs"
	We weten dat we kolommen onderling mogen verwisselen en evenzo voor de rijen. Aan het einde van het algoritme hebben we nog steeds evenveel verboden velden in de kolommen en rijen. Daarom geldt dat de stelling juist is als onze arrays rijen[] en kolommen[] (die het aantal verboden velden in een rij resp. kolom aangeven) bijectief zijn met de veelterm.

Voorbeeld:
% TODO plaatje

Gevolg 1:
	Linksboven in het nieuwe bord heb je altijd een massief blok van verboden velden. Er zijn maar een paar van zulke borden mogelijk bij gegeven hoogte en breedte van het oorspronkelijke bord. We kunnen ze dus opslaan en iedere keer dat we eigenschap 1 aanroepen (en moeten doorrekenen met TWEE borden), ophalen. Zo besparen we voor grote borden heel veel overbodige en dubbele recursieve berekeningen.

Gevolg 2:
	We kunnen ons vermoeden van de tweede stelling mbv het algoritme sterker maken door van het equivalente bord nr_permutaties aan te roepen en dat te vergelijken met het oorspronkelijke bord.

Gevolg 3:
	De worst-case is concreter te bepalen. (Mits we alleen ons speciale geval van eigenschap 1 uitvoeren.) De worst-case voor bijvoorbeeld n = 9 en 27 verboden velden is
	% TODO plaatje
xxx
xxx
xxx
   xxx
   xxx
   xxx
      xxx
      xxx
      xxx

Opmerking: 
	Het bord van het ijsjesprobleem lijkt gegenereerd te zijn en heeft daarom in elke rij en kolom ongeveer evenveel verboden velden (met een bepaalde standaardafwijking).

Gevolg 1:
	Het berekenen van de veelterm van het ijsjesprobleem duurt lang

Gevolg 2:
	We kunnen het aantal operaties dat we moeten doen voor het berekenen van de veelterm van het ijsjesprobleem wél tot op zekere hoogte voorspellen. Aan de hand daarvan en de tijd voor ééén operatie zou je een nauwkeurige laadbalk kunnen maken voor grote, gegenereerde borden.

Opmerking bij gevolg 2:
	Het 5x5 voorbeeld uit het boek duurde gemiddeld 0.162 milliseconden. Getest op 10.000 keer inlezen en berekenen
